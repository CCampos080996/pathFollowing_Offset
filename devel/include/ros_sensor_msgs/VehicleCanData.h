// Generated by gencpp from file ros_sensor_msgs/VehicleCanData.msg
// DO NOT EDIT!


#ifndef ROS_SENSOR_MSGS_MESSAGE_VEHICLECANDATA_H
#define ROS_SENSOR_MSGS_MESSAGE_VEHICLECANDATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace ros_sensor_msgs
{
template <class ContainerAllocator>
struct VehicleCanData_
{
  typedef VehicleCanData_<ContainerAllocator> Type;

  VehicleCanData_()
    : header()
    , vehicleSpeed(0.0)
    , yawRate(0.0)
    , frontLeftWheelSpeed(0.0)
    , frontRightWheelSpeed(0.0)
    , rearLeftWheelSpeed(0.0)
    , rearRightWheelSpeed(0.0)
    , steerAngle(0.0)
    , steerAngleRate(0.0)
    , frontLeftTirePressure(0.0)
    , frontRightTirePressure(0.0)
    , rearLeftTirePressure(0.0)
    , rearRightTirePressure(0.0)  {
    }
  VehicleCanData_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , vehicleSpeed(0.0)
    , yawRate(0.0)
    , frontLeftWheelSpeed(0.0)
    , frontRightWheelSpeed(0.0)
    , rearLeftWheelSpeed(0.0)
    , rearRightWheelSpeed(0.0)
    , steerAngle(0.0)
    , steerAngleRate(0.0)
    , frontLeftTirePressure(0.0)
    , frontRightTirePressure(0.0)
    , rearLeftTirePressure(0.0)
    , rearRightTirePressure(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef float _vehicleSpeed_type;
  _vehicleSpeed_type vehicleSpeed;

   typedef float _yawRate_type;
  _yawRate_type yawRate;

   typedef float _frontLeftWheelSpeed_type;
  _frontLeftWheelSpeed_type frontLeftWheelSpeed;

   typedef float _frontRightWheelSpeed_type;
  _frontRightWheelSpeed_type frontRightWheelSpeed;

   typedef float _rearLeftWheelSpeed_type;
  _rearLeftWheelSpeed_type rearLeftWheelSpeed;

   typedef float _rearRightWheelSpeed_type;
  _rearRightWheelSpeed_type rearRightWheelSpeed;

   typedef float _steerAngle_type;
  _steerAngle_type steerAngle;

   typedef float _steerAngleRate_type;
  _steerAngleRate_type steerAngleRate;

   typedef float _frontLeftTirePressure_type;
  _frontLeftTirePressure_type frontLeftTirePressure;

   typedef float _frontRightTirePressure_type;
  _frontRightTirePressure_type frontRightTirePressure;

   typedef float _rearLeftTirePressure_type;
  _rearLeftTirePressure_type rearLeftTirePressure;

   typedef float _rearRightTirePressure_type;
  _rearRightTirePressure_type rearRightTirePressure;





  typedef boost::shared_ptr< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> const> ConstPtr;

}; // struct VehicleCanData_

typedef ::ros_sensor_msgs::VehicleCanData_<std::allocator<void> > VehicleCanData;

typedef boost::shared_ptr< ::ros_sensor_msgs::VehicleCanData > VehicleCanDataPtr;
typedef boost::shared_ptr< ::ros_sensor_msgs::VehicleCanData const> VehicleCanDataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace ros_sensor_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'sensor_msgs': ['/opt/ros/kinetic/share/sensor_msgs/cmake/../msg'], 'ros_sensor_msgs': ['/home/christian/lateralOffset/src/ros-sensor-msgs/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "75538c77ee37258cf3ed3bf6d0bd45c3";
  }

  static const char* value(const ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x75538c77ee37258cULL;
  static const uint64_t static_value2 = 0xf3ed3bf6d0bd45c3ULL;
};

template<class ContainerAllocator>
struct DataType< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ros_sensor_msgs/VehicleCanData";
  }

  static const char* value(const ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "## Message for vehicle data from CAN bus\n\
std_msgs/Header   header\n\
\n\
float32 vehicleSpeed\n\
float32 yawRate\n\
\n\
float32 frontLeftWheelSpeed\n\
float32 frontRightWheelSpeed\n\
float32 rearLeftWheelSpeed\n\
float32 rearRightWheelSpeed\n\
\n\
float32 steerAngle\n\
float32 steerAngleRate\n\
\n\
float32 frontLeftTirePressure\n\
float32 frontRightTirePressure\n\
float32 rearLeftTirePressure\n\
float32 rearRightTirePressure\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.vehicleSpeed);
      stream.next(m.yawRate);
      stream.next(m.frontLeftWheelSpeed);
      stream.next(m.frontRightWheelSpeed);
      stream.next(m.rearLeftWheelSpeed);
      stream.next(m.rearRightWheelSpeed);
      stream.next(m.steerAngle);
      stream.next(m.steerAngleRate);
      stream.next(m.frontLeftTirePressure);
      stream.next(m.frontRightTirePressure);
      stream.next(m.rearLeftTirePressure);
      stream.next(m.rearRightTirePressure);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct VehicleCanData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ros_sensor_msgs::VehicleCanData_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "vehicleSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.vehicleSpeed);
    s << indent << "yawRate: ";
    Printer<float>::stream(s, indent + "  ", v.yawRate);
    s << indent << "frontLeftWheelSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.frontLeftWheelSpeed);
    s << indent << "frontRightWheelSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.frontRightWheelSpeed);
    s << indent << "rearLeftWheelSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.rearLeftWheelSpeed);
    s << indent << "rearRightWheelSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.rearRightWheelSpeed);
    s << indent << "steerAngle: ";
    Printer<float>::stream(s, indent + "  ", v.steerAngle);
    s << indent << "steerAngleRate: ";
    Printer<float>::stream(s, indent + "  ", v.steerAngleRate);
    s << indent << "frontLeftTirePressure: ";
    Printer<float>::stream(s, indent + "  ", v.frontLeftTirePressure);
    s << indent << "frontRightTirePressure: ";
    Printer<float>::stream(s, indent + "  ", v.frontRightTirePressure);
    s << indent << "rearLeftTirePressure: ";
    Printer<float>::stream(s, indent + "  ", v.rearLeftTirePressure);
    s << indent << "rearRightTirePressure: ";
    Printer<float>::stream(s, indent + "  ", v.rearRightTirePressure);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROS_SENSOR_MSGS_MESSAGE_VEHICLECANDATA_H
